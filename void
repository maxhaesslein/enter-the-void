#!/usr/bin/python


# Enter the Void
# v1, 2023
# by maxhaesslein
# www.maxhaesslein.de

from queue import Queue
from threading import Thread
import numpy as np
import pygame
import pyaudio
import aubio
import os
import sys
import time
import math
import random


options = {
	'screenWidth': 1280,
	'screenHeight': 720,

	'fps': 120, # 30,

    'bufferSize': 512,
    'winSizeMultiple': 2, # 2 or 4

	'verbose': True,

	'windowName': 'Enter the Void',

    'audioDevice': 'auto',
    'audioDisplayScaling': 3000,

    'silenceThreshold': 0.18,
    'beatConfidenceThreshold': 0.01,

    'imagePath': 'assets/',
    'imageExtension': 'png',

    'imageWidth': 180,

}

debugDisplay = {
    'frameCount': False,
    'fps': True, #False,
    'audioFps': False,
    'bpm': False,
    'interval': False,
    'progress': False,
    'pitch': False,
    'volume': False,
    'peaks': False,
}


# setup window
pygame.init()
screen = pygame.display.set_mode((options['screenWidth'], options['screenHeight']), pygame.FULLSCREEN | pygame.NOFRAME )
#screen = pygame.display.set_mode((options['screenWidth'], options['screenHeight']), pygame.FULLSCREEN | pygame.NOFRAME | pygame.OPENGL | pygame.DOUBLEBUF, vsync=1 )
clock = pygame.time.Clock()

pygame.font.init()
font = pygame.font.SysFont( None, 48 )

screen.fill( "black" )
text = font.render('loading ...', True, "white")
textPosition = text.get_rect(center=(screen.get_width()/2, screen.get_height()/2))
screen.blit(text, textPosition)
pygame.display.flip()


# get audio input options
pa = pyaudio.PyAudio()
if options['verbose']:
    print("listing microphones")
    for i in range(pa.get_device_count()):
        dev = pa.get_device_info_by_index(i)
        print(i,dev['name'],dev['maxInputChannels'])
        if options['audioDevice'] == 'auto' and dev['maxInputChannels'] > 0:
            options['audioDevice'] = i
            print('  automatically set audio device to '+str(i))
if pa.get_device_count() < options['audioDevice']:
    print('audio device index is out of range (found '+str(pa.get_device_count())+' audio devices, requested #'+str(options['audioDevice'])+')')
    sys.exit()
audioDevice = pa.get_device_info_by_index(options['audioDevice'])
if audioDevice['maxInputChannels'] <= 0:
    print('audio device has no input channels! aborting')
    print('(use "arecord -l" to check available devices)')
    sys.exit()
audioOptions = {
    'deviceIndex': audioDevice['index'],
    'sampleRate': int(audioDevice['defaultSampleRate']),
    'inputChannels': 1,
    'hopSize': options['bufferSize'],
    'winSize': options['bufferSize']*options['winSizeMultiple'],
}

# get assets
imageFiles = [f for f in os.listdir(options['imagePath']) if os.path.isfile(os.path.join(options['imagePath'], f)) and f.lower().endswith(options['imageExtension'])]

assets = []

for imageFile in imageFiles:
    path = options['imagePath']+imageFile

    image = pygame.image.load(path).convert()

    w = options['imageWidth']
    h = image.get_width()/image.get_height()*w

    image = pygame.transform.smoothscale(image, (w, h))

    size = math.ceil(math.sqrt( math.pow(w, 2) + math.pow(h, 2) ))

    surface = pygame.Surface((size, size)) # add space around the image, so we have enough padding to rotate the image

    surface.blit( image, (int((size-w)/2), int((size-h)/2)) )

    assets.append(surface)


if options['verbose']:
    print('')
    print('---------')
    print('')
    print('-- options --')
    print(options)
    print('')
    print('-- audio options --')
    print(audioOptions)
    print('')
    print('-- assets --')
    print(str(len(assets))+' assets loaded')
    print('')
    print('---------')
    print('')



class AudioProcessor():

    def __init__(self):

        self.fpsMeasurement = options['fps']
        self.previousTime = self.currentTime = time.time()
        self.fpsSmoothing = 0.9

        self.beatQueue = Queue()
        self.bpmQueue = Queue()
        self.periodQueue = Queue()
        self.pitchQueue = Queue()

        peakBufferSize = int(audioOptions['sampleRate']/options['bufferSize']) # one second worth of bufferSizes
        self.peakBuffer = np.zeros(peakBufferSize)
        self.peakBufferBeat = np.zeros(peakBufferSize)
        self.peakBufferIndex = 0

        volumeBufferSize = int((audioOptions['sampleRate']/options['bufferSize'])/options['fps']) # one frame worth of bufferSizes
        if volumeBufferSize < 1:
            volumeBufferSize = 1
        self.volumeBuffer = np.zeros(volumeBufferSize)
        self.volumeBufferIndex = 0

        self.tempoDetection = aubio.tempo(method='default', buf_size=audioOptions['winSize'], hop_size=audioOptions['hopSize'], samplerate=audioOptions['sampleRate'])

        self.pitchDetection = aubio.pitch(method='default', buf_size=audioOptions['winSize'], hop_size=audioOptions['hopSize'], samplerate=audioOptions['sampleRate'])
        self.pitchDetection.set_unit('cent')

        self.audio = pyaudio.PyAudio()
        self.stream = self.audio.open(format=pyaudio.paFloat32,
                    input=True,
                    channels=audioOptions['inputChannels'],
                    input_device_index=audioOptions['deviceIndex'],
                    frames_per_buffer=options['bufferSize'],
                    rate=audioOptions['sampleRate'],
                    stream_callback=self.readAudioFrames)


    def readAudioFrames(self, in_data, frame_count, time_info, status):

        signal = np.frombuffer(in_data, dtype=np.float32)

        volume = np.sum(signal**2)/len(signal)

        beat = self.tempoDetection(signal)
        if beat:
            confidence = self.tempoDetection.get_confidence()
            if confidence > 0.0:
                self.beatQueue.put(confidence)
                bpm = self.tempoDetection.get_bpm()
                self.bpmQueue.put(bpm)
                period = self.tempoDetection.get_period()
                self.periodQueue.put(period)

        pitch = self.pitchDetection(signal)
        if pitch[0] != 0:
            self.pitchQueue.put(pitch[0])

        peak = np.abs(np.max(signal)-np.min(signal))
        self.peakBuffer[self.peakBufferIndex] = peak*options['audioDisplayScaling']
        self.peakBufferBeat[self.peakBufferIndex] = beat

        self.peakBufferIndex += 1
        if self.peakBufferIndex >= len(self.peakBuffer):
            self.peakBufferIndex = 0

        self.volumeBuffer[self.volumeBufferIndex] = volume

        self.volumeBufferIndex += 1
        if self.volumeBufferIndex >= len(self.volumeBuffer):
            self.volumeBufferIndex = 0

        self.previousTime, self.currentTime = self.currentTime, time.time()
        fps = math.ceil(1./(self.currentTime-self.previousTime))
        self.fpsMeasurement = (self.fpsMeasurement*self.fpsSmoothing) + (fps*(1.0-self.fpsSmoothing))

        return (in_data, pyaudio.paContinue)

    def getBeat(self):
        if self.beatQueue.empty():
            return False
        return self.beatQueue.get()

    def getPeriod(self):
        if self.periodQueue.empty():
            return False
        return self.periodQueue.get()

    def getBpm(self):
        if self.bpmQueue.empty():
            return False
        return self.bpmQueue.get()

    def getPitch(self):
        if self.pitchQueue.empty():
            return False
        return self.pitchQueue.get()

    def getPeaks(self):
        return self.peakBuffer, self.peakBufferBeat, self.peakBufferIndex

    def getVolume(self):
        volume = np.sum(self.volumeBuffer)
        return volume

    def getFps(self):
        return self.fpsMeasurement

    def stop(self):
        self.stream.stop_stream()
        self.stream.close()
        self.audio.terminate()


def drawDebugDisplay( beatInformation ):

    # fps debug text
    textY = 0
    if debugDisplay['fps']:
        text = str(int(fps))+' main fps'
        textColor = "green"
        if fps < options['fps']*0.8:
            textColor = "red"
        elif fps < options['fps']*0.9:
            textColor = "yellow"
        textRender = font.render( text, True, textColor )
        textPosition = (screen.get_width()-textRender.get_width(), textY)
        textSurface = pygame.Surface(textRender.get_size())
        textSurface.fill("black")
        textSurface.blit(textRender, (0, 0))
        screen.blit(textSurface, textPosition)
        textY += textRender.get_height()+10

    # audioProcessor fps debug text
    if debugDisplay['audioFps']:
        text = str(math.ceil(audioProcessor.getFps()))+' audio fps'
        textRender = font.render( text, True, "white" )
        textPosition = (screen.get_width()-textRender.get_width(), textY)
        textSurface = pygame.Surface(textRender.get_size())
        textSurface.fill("black")
        textSurface.blit(textRender, (0, 0))
        screen.blit(textSurface, textPosition)

    # frame count debug text
    if debugDisplay['frameCount']:
        text = 'frame #'+str(beatInformation['frameNumber'])+' / next beat at #'+str(int(beatInformation['frameNumber']+beatInformation['framesUntilNextBeat']))
        textRender = font.render( text, True, "white" )
        textPosition = (0, screen.get_height()-textRender.get_height())
        textSurface = pygame.Surface(textRender.get_size())
        textSurface.fill("black")
        textSurface.blit(textRender, (0, 0))
        screen.blit(textSurface, textPosition)

    # bpm debug text
    textY = 0
    if debugDisplay['bpm']:
        text = str(round(beatInformation['bpm']))+' bpm'
        textColor = "white"
        if beatInformation['beat'] and not beatInformation['silence']:
            textColor = "red"
        textRender = font.render( text, True, textColor )
        textX = int((screen.get_width()-textRender.get_width())/2)
        textPosition = (textX, textY)
        textSurface = pygame.Surface(textRender.get_size())
        textSurface.fill("black")
        textSurface.blit(textRender, (0, 0))
        screen.blit(textSurface, textPosition)
        textY += textRender.get_height()+10

    # fpi debug text
    if debugDisplay['interval']:
        text = str(round(beatInformation['framesPerInterval']))+' frames per interval'
        textColor = "white"
        if beatInformation['beat'] and not beatInformation['silence']:
            textColor = "red"
        textRender = font.render( text, True, textColor )
        textX = int((screen.get_width()-textRender.get_width())/2)
        textPosition = (textX, textY)
        textSurface = pygame.Surface(textRender.get_size())
        textSurface.fill("black")
        textSurface.blit(textRender, (0, 0))
        screen.blit(textSurface, textPosition)

    # print progress bar until next beat
    y = int(screen.get_height() * 2/3)
    x = 300
    w = int(screen.get_width() - x*2)
    h = 30
    if debugDisplay['progress']:
        color = "white"
        if beatInformation['lateBeat']:
            color = "red"
        filledWidth = round((1-(beatInformation['framesUntilNextBeat']/beatInformation['framesPerInterval']))*w)

        text = 'next beat'
        textRender = font.render( text, True, color )
        textY = int(h/2-textRender.get_height()/2)

        elementSurface = pygame.Surface((textRender.get_width()+10+w, h))
        elementSurface.fill("black")
        pygame.draw.rect(elementSurface, color, (textRender.get_width()+10,0,w,h), True)
        pygame.draw.rect(elementSurface, color, (textRender.get_width()+10,0,filledWidth,h), False)
        elementSurface.blit(textRender, (0, textY))
        screen.blit(elementSurface, (x-textRender.get_width()-10, y))

        y += h + 20

    # print pitch
    if debugDisplay['pitch']:

        filledWidth = int((beatInformation['pitch'])*w/100)
        pygame.draw.rect(screen, "white", (x,y,w,h), True)
        pygame.draw.rect(screen, "white", (x,y,filledWidth,h), False)

        text = 'pitch'
        textRender = font.render( text, True, "white" )
        textY = int(h/2-textRender.get_height()/2)

        elementSurface = pygame.Surface((textRender.get_width()+10+w, h))
        elementSurface.fill("black")
        pygame.draw.rect(elementSurface, "white", (textRender.get_width()+10,0,w,h), True)
        pygame.draw.rect(elementSurface, "white", (textRender.get_width()+10,0,filledWidth,h), False)
        elementSurface.blit(textRender, (0, textY))
        screen.blit(elementSurface, (x-textRender.get_width()-10, y))

        y += h + 20

    # print Volume
    if debugDisplay['volume']:

        text = 'volume'
        textRender = font.render( text, True, "white" )
        textY = int(h/2-textRender.get_height()/2)

        midW = int(w/2)

        color = "white"
        if beatInformation['silence']:
            color = "red"
        silenceMarker = round(w/2*options['silenceThreshold'])
        filledWidth = int(midW*(beatInformation['volumePercent']-1))
        if filledWidth > w/2:
            filledWidth = w/2

        filledX = 0
        if filledWidth < 0:
            filledX += filledWidth
            filledWidth *= -1

        elementSurface = pygame.Surface((textRender.get_width()+10+w, h))
        elementSurface.fill("black")
        pygame.draw.rect(elementSurface, color, (textRender.get_width()+10+filledX+midW,0,filledWidth,h), False)
        pygame.draw.rect(elementSurface, color, (textRender.get_width()+10,0,w,h), True)
        pygame.draw.rect(elementSurface, color, (textRender.get_width()+10+silenceMarker,0,2,h), True)
        elementSurface.blit(textRender, (0, textY))
        screen.blit(elementSurface, (x-textRender.get_width()-10, y))

    # print peaks
    if debugDisplay['peaks']:
        data, beatData, index = audioProcessor.getPeaks()
        index -= 1
        if index < 0:
            index = options['fps']-1

        w = math.ceil(options['screenWidth']/len(data))
        x = options['screenWidth']-w
        y = int(options['screenHeight']*3/5)
        h = 4
        color = (255,255,255)

        for i in range(len(data)):
            y2 = int(data[index])
            o = beatData[index]

            if o:
                pygame.draw.rect(screen, "red", (x,y-200,4,200), False)

            pygame.draw.rect(screen, "white", (x,y-y2,w,h), False)

            x += w

            index += 1
            if index >= len(data):
                index = 0
            if x >= options['screenWidth']:
                x = 0


def getBeatInformation():

    global framesUntilNextBeat, pitchValue, volumeBufferIndex, bpm, framesPerInterval, lateBeat, frameNumber, volumePercentMeasurement

    framesUntilNextBeat -= 1
    if framesUntilNextBeat < 0:
        lateBeat = True
        framesUntilNextBeat = 0

    beat = False
    beatConfidence = audioProcessor.getBeat()
    if beatConfidence > options['beatConfidenceThreshold']:
        bpm = audioProcessor.getBpm()
        period = audioProcessor.getPeriod()
        beat = True
        framesPerInterval = framesUntilNextBeat = fps*period/audioOptions['sampleRate']
        lateBeat = False
    elif options['verbose'] and beatConfidence > 0.0:
        print('beat detected, but confidence too low', beatConfidence)

    if pitchValue > 0:
        oldPitchValue = pitchValue
    pitchValue = 0
    pitch = audioProcessor.getPitch()
    if pitch and pitch > 0:
        pitchValue = pitch

    globalVolume = audioProcessor.getVolume()
    volumeBuffer[volumeBufferIndex] = globalVolume
    volumeBufferIndex += 1
    if volumeBufferIndex >= len(volumeBuffer):
        volumeBufferIndex = 0
    globalAverageVolume = np.sum(volumeBuffer)/len(volumeBuffer)

    if globalVolume > 0:
        volumePercent = globalVolume/globalAverageVolume
    else:
        volumePercent = 1

    if volumePercent > 2:
        volumePercent = 2

    volumeDisplaySmoothing = 0.7
    volumePercentMeasurement = (volumePercentMeasurement*volumeDisplaySmoothing) + (volumePercent * (1.0-volumeDisplaySmoothing))

    silence = False
    if volumePercentMeasurement < options['silenceThreshold']:
        silence = True

    beatInformation = {
            'fps': fps,
            'frameNumber': frameNumber,
            'beat': beat,
            'bpm': bpm,
            'beatConfidence': beatConfidence,
            'lateBeat': lateBeat,
            'framesUntilNextBeat': framesUntilNextBeat,
            'framesPerInterval': framesPerInterval,
            'pitch': pitchValue,
            'volume': globalVolume,
            'averageVolume': globalAverageVolume,
            'volumePercent': volumePercentMeasurement,
            'silence': silence,
    }

    return beatInformation



s_img_index = random.randint(0,len(assets)-1)
y_offset = 0
x_offset = 0
rotation = 0
rotationAcceleration = 50
rotationDirection = 1
backgroundHue = random.randint(0,360)

s_img = assets[s_img_index]

# TODO: change direction randomly
# TODO: make size and number of elements depended on variable, change randomly
# TODO: this needs to reset, when we change the number of displayed elements
size = math.floor(s_img.get_height()*1.5)
left_img = pygame.Surface((s_img.get_width(), size))
element = pygame.Surface((size,size))
elementSlice = pygame.Surface((size,size))
elementSliceColor = pygame.Surface((size,size))

def drawFrame( beatInformation, dt ):

    global s_img_index, rotation, rotationDirection, rotationAcceleration, backgroundHue, left_img, element, elementSlice, elementSliceColor

    p = beatInformation['framesUntilNextBeat']/beatInformation['framesPerInterval']

    rotationAcceleration -= 0.05

    backgroundHue += 1
    if backgroundHue >= 360:
        backgroundHue -= 360

    if beatInformation['silence']:
        rotationAcceleration -= 2

    if rotationAcceleration < 0:
        rotationAcceleration = 0

    if beatInformation['beat'] and not beatInformation['silence']:

        rotationAcceleration += 20

        if rotationAcceleration > 100:
            rotationAcceleration = 100

        if beatInformation['beatNumber']%32 == 0:
            rotationDirection *= -1

        if beatInformation['beatNumber']%64 == 0:

            backgroundHue += random.randint(0,180)
            if backgroundHue >= 360:
                backgroundHue -= 360

            s_img_index += 1
            if s_img_index >= len(assets):
                s_img_index = 0

    s_img = assets[s_img_index]

    rotation += dt*rotationAcceleration*rotationDirection

    rect = s_img.get_rect()
    lt_img, lt_rect = rotate(s_img, rect, rotation)

    left_img.fill("black")
    left_img.blit(lt_img, lt_rect)

    lb_img = pygame.transform.flip(lt_img, False, True)
    lb_rect = lb_img.get_rect(center=(s_img.get_width()/2,s_img.get_height()))
    left_img.blit(lb_img, lb_rect, special_flags=pygame.BLEND_ADD)

    element.fill("black")
    element.blit(left_img, (0,0))

    right_img = pygame.transform.flip(left_img, True, False)
    right_rect = right_img.get_rect(center=(size*2/3,size/2))

    element.blit(right_img, right_rect, special_flags=pygame.BLEND_ADD)

    backgroundColor = pygame.Color(0,0,0)
    backgroundSaturation = 50+p*30
    if beatInformation['silence']:
        backgroundSaturation = 50
    backgroundColor.hsva = (backgroundHue, backgroundSaturation, 50, 100)

    elementSlice.fill("black")

    elementSlice.blit(element, (0,0), special_flags=pygame.BLEND_ADD)
    elementSlice.blit(element, (-size/2,0), special_flags=pygame.BLEND_ADD)
    elementSlice.blit(element, (size/2,0), special_flags=pygame.BLEND_ADD)

    elementSliceColor.fill(backgroundColor)
    elementSliceColor.blit(elementSlice, (0,0), special_flags=pygame.BLEND_ADD)

    centerY = round((screen.get_height()-size)/2)

    if beatInformation['bpm'] >= 150:
        speed = 4
    elif beatInformation['bpm'] >= 130:
        speed = 3
    elif beatInformation['bpm'] >= 110:
        speed = 2
    else:
        speed = 1

    posX = int(beatInformation['frameNumber']%(screen.get_width()/(7*speed))*speed)
    posX *= rotationDirection

    posX -= int(screen.get_width()*1/5)
    if rotationDirection > 0:
        posX -= int(screen.get_width()*2/5)

    screen.fill(backgroundColor)

    screen.blit(elementSliceColor, (posX,centerY-size*2/3))
    screen.blit(elementSliceColor, (posX+size,centerY-size*2/3))
    screen.blit(elementSliceColor, (posX+size*2,centerY-size*2/3))
    screen.blit(elementSliceColor, (posX+size*3,centerY-size*2/3))
    screen.blit(elementSliceColor, (posX+size*4,centerY-size*2/3))
    screen.blit(elementSliceColor, (posX+size*5,centerY-size*2/3))

    screen.blit(elementSliceColor, (posX,centerY+size*2/3))
    screen.blit(elementSliceColor, (posX+size,centerY+size*2/3))
    screen.blit(elementSliceColor, (posX+size*2,centerY+size*2/3))
    screen.blit(elementSliceColor, (posX+size*3,centerY+size*2/3))
    screen.blit(elementSliceColor, (posX+size*4,centerY+size*2/3))
    screen.blit(elementSliceColor, (posX+size*5,centerY+size*2/3))

    screen.blit(elementSlice, (posX,centerY), special_flags=pygame.BLEND_ADD)
    screen.blit(elementSlice, (posX+size,centerY), special_flags=pygame.BLEND_ADD)
    screen.blit(elementSlice, (posX+size*2,centerY), special_flags=pygame.BLEND_ADD)
    screen.blit(elementSlice, (posX+size*3,centerY), special_flags=pygame.BLEND_ADD)
    screen.blit(elementSlice, (posX+size*4,centerY), special_flags=pygame.BLEND_ADD)
    screen.blit(elementSlice, (posX+size*5,centerY), special_flags=pygame.BLEND_ADD)


def rotate(image, rect, angle):
    # Rotate the original image without modifying it.
    new_image = pygame.transform.rotate(image, angle)
    # Get a new rect with the center of the old rect.
    rect = new_image.get_rect(center=rect.center)
    return new_image, rect



targetTime = 1./options['fps']
frameNumber = 0
beatNumber = 0
bpm = -1
framesPerInterval = -1
framesUntilNextBeat = -1
lateBeat = False
pitchValue = 0
oldPitchValue = 0

volumeBuffer = np.zeros(options['fps']*10) # 10 seconds worth of frames
volumeBufferIndex = 0
globalVolume = 0
globalAverageVolume = 0
volumePercentMeasurement = 1

fps = options['fps']
fpsDisplay = options['fps']

verbose = False

audioProcessor = AudioProcessor()

running = True
dt = 0

# main loop
while running:

    # poll for events; pygame.QUIT event means the user clicked X to close your window
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False
            elif event.key == pygame.K_q:
                debugDisplay['fps'] = not debugDisplay['fps']
            elif event.key == pygame.K_w:
                debugDisplay['audioFps'] = not debugDisplay['audioFps']
            elif event.key == pygame.K_e:
                debugDisplay['frameCount'] = not debugDisplay['frameCount']
            elif event.key == pygame.K_r:
                debugDisplay['bpm'] = not debugDisplay['bpm']
            elif event.key == pygame.K_t:
                debugDisplay['interval'] = not debugDisplay['interval']
            elif event.key == pygame.K_z:
                debugDisplay['progress'] = not debugDisplay['progress']
            elif event.key == pygame.K_u:
                debugDisplay['pitch'] = not debugDisplay['pitch']
            elif event.key == pygame.K_i:
                debugDisplay['volume'] = not debugDisplay['volume']
            elif event.key == pygame.K_o:
                debugDisplay['peaks'] = not debugDisplay['peaks']
            elif event.key == pygame.K_v:
                verbose = not verbose

    beatInformation = getBeatInformation()

    if beatInformation['beat'] and not beatInformation['silence']:
        beatNumber += 1

    beatInformation['beatNumber'] = beatNumber

    drawFrame( beatInformation, dt )
    drawDebugDisplay( beatInformation )

    pygame.display.flip() # update screen

    frameNumber += 1 # TODO: check, when this rolls over

    # limits FPS; dt is delta time in seconds since last frame, used for framerate-independent physics.
    dt = clock.tick(options['fps']) / 1000

    fps = clock.get_fps()


print('cleaning up ..')

audioProcessor.stop()
pygame.quit()

print('bye!')

